LESSON 3: BUILT-INS

- Symbols
	
	- unique identifier (usu) to identify properties within an object
	- imagine you want to add multiple of the same kind of properties to an obj
		- like bananas in a bowl, once you add >1, you start having to keep track of them
		- if you add a new 'banana' to an object, you just overwrite the prev 'banana'
		- common solution is to number them banana1, banana2, ...
	- symbols have an optional description but that string isn't the symbol itself
	
	const symNoDesc = Symbol();
	const b1 = Symbol('banana');
	const b2 = Symbol('banana');
	b1 === b2; 						// false

	- using symbols within an object
	const bowl = {
		[Symbol('apple')]: {color:'red'},
		[Symbol('banana')]: {color:'yellow'},
		[Symbol('banana')]: {color:'brown'}
	};

- Iterable protocol
	- for...of as a built-in iterable usable on any iterable object
	- any iterable object must implement the "iterable interface"
		- basically means it must contain a default iterator method
		- default method defines how obj is to be iterated
	- iterator method is avail via the constant [Symbol.iterator]
		- it's a zero arg func that returns an iterator obj
		- an iterator obj is an obj that conforms to the iterator protocol
	- iterator protocol
		- defines standard way an obj produces a sequence of value
		- really means that you have a process for determining how obj will iterate
	- obj becomes iterator when implements .next()
	- .next() returns an obj w two properties:
		- value (the next value in the obj)
		- done (boolean for done going through sequence of values)

	const digits = [0,1,2,3,4,5];
	const arrayIterator = digits[Symbol.iterator]();
	console.log (arrayIterator.next());		// Object {value: 0, done: false}
	console.log (arrayIterator.next());		// Object {value: 1, done: false}

	- iterating through an object

	// sample object
	const james = {
 	   name: 'James',
	    height: `5'10"`,
	    weight: 185
	};

	// generator function
	james[Symbol.iterator] = function* () {
    	const keys = Object.keys(james);
    	for (const key of keys) {
        	yield james[key];
    	}
	}

	let iterator = james[Symbol.iterator]();
	console.log(iterator.next().value); 		// 'James'
	console.log(iterator.next().value); 		// `5'10`
	console.log(iterator.next().value); 		// 185


	// change the next method to return what you want from an object
	// here getting the key as well as the value and done
	james[Symbol.iterator] = function () {
		let i = 0;
		const keys = Object.keys (this);
		return {
			next: () =>  {
				let done;
				if (i < keys.length) {
					done = false;
					i++;
				} else {
					done = true;
				}
				return { key: keys[i-1], value: this[keys[i-1]], done: done };
			}
		};
	}

- Sets
	- collections of unique elements
	- unlike array, cannot be dups

	const games = new Set({'Mario','Banjo','Cod','Borderlandias'});
	
	- .add() and .delete() an item from a set
	games.add ('Mario2'); 		// false if unsuccessful (like item already in set) but no error
	games.delete ('Banjo'); 	// false if unsuccessful (like item not in set) but no error

	- clear the set
	games.clear();

	- other properties
	games.size; 		 	// length of the array
	games.has('Mario'); 	// if item exists
	games.values(); 		// returns a SetIterator object
	games.keys();			// an alias for .values() for similarity with maps

	- sets are built-in iterables so:
		(1) you can use default iterator to step through each item in a Set one by one
		(2) you can use for...of to loop through items in a Set

	- (1) stepping through requires using .next on SetIterator values
	const iterator = games.values();
	iterator.next(); 		// Object {value: 'Mario', done: false}
	iterator.next(); 		// and so on...

	- (2) for...of as easier
	for (const game of games) { ... }

- WeakSets

	- can ONLY hold objects
	- is NOT iterable (no looping over or stepping through!)
	- doesn't have .clear()

	- why use? GC!
		- if you set an object to null it's removed from the set automatically
		- null objects are effectively deleted ones
		- so effectively this means you don't have to worry about your set pointing to deleted objects

- 