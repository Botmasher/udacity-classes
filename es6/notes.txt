LESSON 1: SYNTAX

- Harmony = ES6 = ES2015, diff names for biggest update to JS

- let, const

	- using var gets us into trouble; what happens when isCold = false?
	function getClothing (isCold) {
		if (isCold) {
			var freezing = 'Grab your jacket!';
		} else {
			var hot = 'Grab your shorts!';
			console.log (freezing); 			// logs "undefined"!
		}
	}

	- hoisting: all vars raised to top of scope!
	function getClothing (isCold) {
		var freezing, hot; 						// it's as if vars declared here
		if (isCold) {
			freezing = 'Grab your jacket!';
		} else {
			hot = 'Grab your shorts!';
			console.log (freezing); 			// that's why it's "undefined"!
		}
	}

	- let and const scope to BLOCK, not to func
	- the let/const is stuck in a "temporal dead zone" btwn its {}
	- can only access let/const variable after they've been declared
	function getClothing (isCold) {
		if (isCold) {
			let freezing = 'Grab your jacket!';
		} else {
			let hot = 'Grab your shorts!';
			console.log (freezing); 			// NOW get reference error: freezing not defined
		}
	}

	- let can reassign but not redeclare within same scope
	- const must be assigned initial value, cannot reassign, cannot redeclare in same scope
	- const is strictest way to declare a variable; won't change during lifetime of program
	let instructor = 'J';
	instructor = 'R';
	console.log (instructor);		// 'R'; SyntaxError identifier 'instructor' already declared if const

	- not really reason to use var anymore! (maybe in globally defined vars? but this as bad practice worth ditching)

- template literals

	- previous clunky concatenation c e.g. teacher.name + " in " + teacher.room (or String ''.concat() method)

	- now template literals allow string interpolation, referencing object's properties inside expressions
	let mssg = `${teacher.name} has your report card in ${teacher.room}`;

	- template literals preserve newlines as part of the string!
	let note = `${teacher.name},

		Please excuse ${student.name}.
		He was hit by a stray tetherball.
	
		Thank you,
		${student.guardian};

	- the "embedded expressions" can also do operations, call functions, loops!

- Destructuring arrays and objects

	- extract data into distinct variables
	- old way of creating vars and assigning vals to each (say x,y,z for a vect) isn't truly destructuring
	- instead, like Python, specify extracted elements on left hand of assignment
	const point = [10, 2, -5];
	const [x,y,z] = point; 			// destructuring, where [] represent the array being destructured
	const [a,,c] = point; 			// destructuring, ignoring/discarding certain vals

	- or do it with {} for an object being destructured
	const circle = {
		radius: 10,
		getArea: function() {
			return Math.PI * this.radius * this.radius;
		},
		getCircumference: function() {
			return Math.PI * 2 * this.radius;
		}
	};
	let {radius,getArea,getCircumference} = circle; 		// selects properties by their name
	// NOTE getArea() when called no longer has ref to THIS.radius! SO it returns NaN!

- Object literal shorthand
	- remove repetition when object initialized with same property names as prev declared variable names
	let type = 'emerald';
	let color = 'green';
	let carat = '21.29';
	let gemstone = {type, color, carat}; 	// old way was type: type, color: color, carat: carat

	- remove 
	let gemstone = {
		type,
		color,
		carat,
		calculateWorth() {...} 				// old way was calculatWorth: function() {...}
	}

- 