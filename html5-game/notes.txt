HTML 5 GAME DEVELOPMENT

- Welcome! There's an optional JS crash course at the end if not familiar.

0. CANVAS
(Hey, didn't I just take this? ;)
- How to write a 2d, tile-based engine: HTML5 canvas element
- Canvas as large memory blob of pixel data
	- it's an HTML5 drawing surface that exposes APIs
	- 2 attribs spec to it: width and height
- canvas.getContext('2d');
	- handle to the drawing APIs we'll use
- FULLSCREEN == window.innerWidth, window.innerHeight
- IMAGES
	1. declare Image() object
	2. define onload()
	3. set image.src
	(JS kicks off a load func once source is set!)
- canvas.drawImage(img, posX, posY) from top L corner of canvas
- jpeg for size vs png for alpha vs webp for both
- ANIMATION
	- simple flipbook:
		0. setup frame and framerate variables
		1. load an array of imgs into a frames var
			frames.push(new Image());
			frames[i].onload = // your load func ;
			frames[i].src = // your img src ;
		2. animate setInterval every say 30 ms (but last class did render frame)
		3. when you draw frames in animate func, set to loop back around:
*			frame = (frame + 1) % frames.length; 		// get it?!?
		4. add clearRect for no skinning
- Awesome story about Carmack and "Dirty Rect"

1. ATLASES
- as # images in asset set increases, ups drawing to screen complexity
- browser has upper limit on # connections available
	- if only 6 connections available and >6 requests, the other requests get stacked until something gives
	- ask for 1 big img 241 ms VS split it into 16 smaller 4 secs!
	- pack imgs together and deliver at once
- Texture Atlasing: packing smaller imgs into larger imgs
	- well-studied process in most games
	- 1 Tex Atlas contains many smaller sub-imgs each ref'd indepdtly
- vs "Spritesheets", a term originally just for animated objects
	- Atlases might be say bg tiles
	- this is a bone of contention in game dev jargon!
** TEXTURE PACKING: tricky engineering "bin packing problem"!
	- NP Hard, he uses it as an interview question
	- Atlas info in JSON format
	- list of img names (the "original LOOSE ASSET"), and for each img:
		- frame: x, y, w, h  			// the img within the atlas
		- rotated: true/false
		- trimmed: true/false
		- spriteSourceSize: {x,y,w,h} 	// for drawing to our canvas
		- sourceSize: {w,h}
*	Texture Packing Quiz
		0. Write a defSprite method that takes a (name,x,y,w,h,cx,cy)
			- center x and center y are negative offsets from w and h
			- do this here so don't have to calculate later on!
		1. Map those values to an object
		2. Add that object to a sprites array
		3. Load JSON atlas data and parse it

		4. Call the define sprites method on that json data
* drawImage - the advanced version
	- not just x,y,w,h BUT ALSO a SOURCE x,y,w,h vs a DEST x,y,w,h
	- clearly handy for outputting imgs from our atlas to our canvas!!
	- any diff in s_ -> d_ vals is handled by SCALING
		- e.g. if sx=10 and dx=5, img scaled in half along x
- We're still missing a link between artist file (loose asset) + atlas
*	FIX THIS!
		0. drawSprite function that takes name of loose asset and x,y
		1. a dictionary of all atlases and all images in spritesheets
		2. __drawSpriteInternal (sprite, sheet, posX, posY) {}
		3. drawSprite figures out what atlas this sprite was in
		4. drawSprite passes that info to __drawSpriteInternal
		5. __drawSpriteInternal heavy lifting of positioning/drawing
		* Pass in the ENTIRE SPRITESHEET to drawImage
		* draw image with axis origin at center:
			- hold off {x: posX-sprite.w*0.5, y: posY-sprite.h*0.5}
			- use those .x, .y vals when drawing positionX, positionY
- Now handle TRIMMED sprites (usually cut out alpha edges)
	0. Smart trim crops from the edges to the center. Think on this.
	1. Initialize new center x and center y vals
	2. From the sprite JSON, get the trimmed img's x y w h
	3. subtract half the height from the y, half the width from the x
		- This accounts for the cropped offset from the bottom r corner (in other words, from the w and h vals of the img)
		- Think why: geometrically, we are now moving the image "behind" its starting w h values. From now on, we can call those vals when we draw the trimmed image!
- The classic tools aren't dead in HTML5!
	- can read traditional formats that you might not expect
	- important for new game devs and studios who think they have to reinvent all tools to work in HTML5
- ENVIRONMENTS: drawing the 2D map
	- have atlas that works like the sprites
*	- TILE also generates for us a large, complex data file
		- this shows how atlas should be rendered to draw bg
		- big games would have artist take this
		- here we're going to read in our json.
		- Tile tells us which atlases to load and how the layers are organized on top of each other
	0. setup an XHR
		function xhrGet(reqUri,callback) {
			var xhr = new XMLHttpRequest();
			xhr.open("GET", reqUri, true);
			xhr.onload = callback;
			xhr.send();
		}
	1. perform an XHR to load tiles
		var TILEDMapClass = Class.extend({
		    // Boolean flag set once map atlas loads
		    fullyLoaded: false,
		    load: function (map) {
		        // Perform an XMLHttpRequest to grab the
		        // JSON file at url 'map'. We've provided
		        // the xhrGet function from the optional
		        // unit for you to use if you want.
		        //
		        // Once the XMLHttpRequest loads, set the
		        // 'fullyLoaded' flag to true.
		        //
		        xhrGet(map, false, function(data) {
		            this.fullyLoaded = true;
		        });       
		    }
		});
	2. Parse the JSON file
		- initial parameters: size of tile map expects (tilew, tileh)
		- initial params: # of vert and horiz tiles used (width)
		- understand dimensions: width * tilewidth gives # pixels w
		- "tilesets": which atlases, including paths and firstgid
		- separate section devoted to layers:
			- "data": HUGE array of ints for each tile placed this lyr
			- "type": whether it's a tile lyr or an object lyr
		- Raster Scan Order: each row listed after previous row
		- Any non-zero val in data reps a tile index for a given atlas
			- That "firstgid" for each atlas in "tilesets"
			- Each atlas inside tile has its own gid
			- Tiled has own heuristic for each subsequent loaded atlas, don't worry, but be aware
			- 167 = 1st gid (atlas), tile 166 /!\
	3. Loading the tile maps (COMPLEX procss)
		- modify xhrGet to call a parseMapJSON function
		- in parseMapJSON, assign JSON.parse(mapJSON)
		- use assigned this.currentMapData to cache vals
			( kw THIS refers to gMap object the function is within )
			- avoids walking thru the JSON later on
			- first vals to care about are:
				a. num X tiles, num Y tiles
				b. size of tiles x,y
				c. pixel size of the entire map x, y
					( calc based on num tiles * size of tiles)
		- set the fullyLoaded attribute to true
*		/!\ Parse function still not working even when perfectly matches instructor solution /!\
	4. Loading tileset data described in the file
		- create a new image for each tile
		- set a callback function for once done loading
		- set the source value to the tileset's img attribute
*		- kicking off ASYNCHRONOUS loads of imgs when our map is ALREADY asynchronously loading!
		- so wait to set fullyLoaded to true until after all tilesets fully loaded into memory (use a counter val)
		for (loop thru tilesets) {
			var img = new Image();
			img.onload = function () {
				this.imgLoadCount++;
				if (this.imgLoadCount === tilesets.length) {
					this.fullyLoaded = true;
				}
			};
			img.src = tilesets.imgURL;
		}
	5. Final parsing step: keep an array of avail tileSets
		
		- create a new object with all relevant tile attributes
		
		- map the tileset attributes from JSON to obj properties
		ts = { "firstgid":map.tilesets[i].firstgid,
		// and so on for width, height, name

		// your number of x and y tiles will need to factor in both the JSON tileset and your local properties
		"numXTiles": Math.floor(map.tilesets[i].imagewidth / this.tilesize.x),
        "numYTiles": Math.floor(map.tilesets[i].imageheight / this.tilesize.y)
        }

		- push that object to the new array tileSets
		this.tilesets.push(ts);

	6. Now find img and coord of spec tile in tileset from our array
		// create function that takes index and returns tile packet
		// tile pkt contains atlas img and x,y index for the tiel
		getTilePacket: function(tileIndex) {

			var pkt = { "img": null, "px": 0, "py": 0 };

			// tileIndex will be <= firstgid
			var i;
			for (i=0; i < this.tileSets.length; i++) {
				if this.tileSets[i].firstgid >= tileIndex {
					pkt.img = this.tileSets[i].image;
					break;
				}
			}

			// calc x and y values based on tile arrangement
			var localId = tileIndex-this.tileSets[i].firstgid;
					
			var localX = Math.floor(localId % this.tileSets[i].numXTiles);
			var localY = Math.floor(localId / this.tileSets[i].numXTiles);
			// stumped like me? It's simple geometry! For x offset in grid, all you need to find is how many tiles you are from the left (the remainder, hence modulo). For y offset in grid, all you need to know is how many groups of x you've already been over (hence the division)!

			// factor in the output tilesizes (you just have indexes)
			pkt.px = localX * this.tileSize.x;
			pkt.py = localY * this.tileSize.y;

			// good to go!
			return pkt;
		}
	7. Prepare for drawing! - which tiles to draw from parsed data
		- (Check that gMap was fully loaded)
		- Layer data in JSON file, very often 0's (no tile)
		- Loop through each layer
		- For each layer loop thru tile id's in the data of each layer
		- A significant % of them will be set to 0 (draw no tiles)
		- If tile id isn't 0, grab getTilePacket (above) with that id
		
		// ignore if the map isn't loaded yet
		if(!gMap.fullyLoaded) return;

		// variables for making my loop life easier
        lyrs = this.currMapData.layers;
        var pkt;

        // dig into each tile id within data within layers
        for (var i = 0; i < lyrs.length; i++) {
            if (lyrs[i].type === "tilelayer") {
                for (var j=0; j < lyrs[i].data.length; j++) {
                    if (lyrs[i].data[j] !== 0) {
                        pkt = this.getTilePacket(lyrs[i].data[j]);
                    }
                }
            }
        }

    8. Actually draw the tile to the game world
    	- figure out where based on the tile id and gmap tiles across
    	- figure out the x/y size of the tile
    	- combine these to set up the x/y offset from canvas origin

    	// use same x y magic from the tile packet to figure world XY
    	var worldX = Math.floor(tileIndex % this.numXTiles) * this.tileSize.x;
    	var worldY = Math.floor(tileIndex / this.numXTiles) * this.tileSize.y;

    	// Draw the image to the canvas
    	// Note this.tileSize is repeated to keep scaling same
    	/* 
    	 * If you're digging into this code, do yourself a favor and
    	 *   bring up the documentation for these 9 args!
    	 * It's basically source img, pos, scale (5 args) and 
    	 *   target pos, scale (4 args).
    	 */
    	ctx.drawImage (pkt.img, pkt.px, pkt.py, this.tileSize.x, this.tileSize.y, worldX, worldY, this.tileSize.x, this.tileSize.y);

2. INPUT
	- capture input and react to it properly
	- WASD + mouse input (or arrow keys) for turret
	- turret doesn't update until ready to fire (fire rate)
	- combinations of arrow or mouse directions for shooting diagonals
	- (Un)fair gameplay:
		- back in the day, turning down resolution or using DSL instead of dialup on Quake to get unfair advantage
		- in this game, pay attention to fairness from the get-go
		- mouse won't have extra degrees of freedom compared to keys
	- JS input data is like newspaper subscriptions
		- subscribe to a process like onMouseMove, onKeyDown, onClick
		- decide what function you'll call when that event happens
	- hook up mouse move and key down from events to methods

	// the mousemove event contains clientX, clientY coords
	// while keydown event contains a KeyID property

	function setup() {
		document.getElementById('canvas').addEventHandler('mousemove', onMouseMove);
		document.getElementById('canvas').addEventHandler('keydown', onKeyDown);
	}

	function onMouseMove(event) {
		return (event.clientX, event.clientY);
	}

	function onKeyDown(event) {
		return event.keyID;
	}

*	- Bad practice to respond to even within callback
		- Update loop and render can get out of sync, because input from browser can come at pretty much any time even after we've already made decisions for where to place everything that frame
		- Instead, we keep the input and hold it, allowing update loop to query it whenever it wants

	- Set up to handle key input

		// array for ASCII values
		var keyState = [];
    	keyState.length = 256;
    	keyState = Array.apply(this, keyState);
	    
	    // add an event handler 
	    document.getElementById('canvas').addEventHandler('keyup', funcName);
	   	document.getElementById('canvas').addEventHandler('keydown', funcName);

	    // build functions to set true on keydown and false on keyup
	    // basically both funcs set keyState[event.keyID] = t/f
	
	- Keymapping allows user-customized keys
		- variably modify what key corresponds to what action
		- instead of checking for ASCII values, query for action names
		- example would be checking for 'move-up' instead of '87'
		- create a bind function and a bindings dictionary alongside that key values dictionary
		- create an actions dictionary that maps values to true/false

		// onKeyDown now sets the action to true
		this.actions[this.bindings[event.keyID]] = true;

		// onKeyUp now sets the action to false
		this.actions[this.bindings[event.keyID]] = true;\

		// the new bind function maps keys to actions
		bind: function(key,action) {
			this.bindings(key) = action;
		},

		// make sure to avoid out of bounds errors for null actions

	- Using physics, teleportation becomes a problem
		- lack a straightforward way to pick up and move player
		- can't ignore the physics going on without confusing physics engine
		- e.g. if we move player to intersect with wall, get stuck
	
	- Instead, update the physics (velocity) so that the effect is moving the player where we want to
*		- "Teleportation issues"
		- Constrain physics through API to move properly on input
		- separate out GameEngine.js (physics) versus InputEngine.js
*		- We're using Box2d which has a Vec2 constructor

		// check for actions move-up, move-down, move-left, move-right
		if (gInputEngine.actions['move-up']){
			// adjust the move_dir vector 2
			// remember canvas! up is -y and down is y!!
			move_dir.y -= 1;
		}

		// 
		// Check that the squared length of the vector is non-zero
		if (move_dir.LengthSquared()) {
			// turn the vector into unit of length 1.0
			move_dir.Normalize();
			// adjust vector length based on player's walk speed
			// multiplies vector's components by a scalar (arg0)
			move_dir.Multiply(this.Player0.walkSpeed);
		}

		// Set the player velocity through the physics body
		gGameEngine.gPlayer0.mpPhysBody.setLinearVelocity(gGameEngine.move_dir.x, gGameEngine.move_dir.y);

	- Mouse firing your fancy missiles towards other robots
		1. Find directional vector from robot to mouse cursor in game space. Subtracting mouse position from the robot position, giving us an unnormalized Vec2
		2. Normalize this Vec2
		3. Use normalized Vec2 to find the velocity path for the projectile
		4. Now actually launch the thing (later)

		if (gInputEngine.actions.fire0 || gInputEngine.actions.fire1){

			// use provided gRenderEngine.getScreenPosition method
			// to grab player's onscreen x and y
		    var playerCanvasPos = {
		        x: gRenderEngine.getScreenPosition(gGameEngine.gPlayer0.pos).x,
		        y: gRenderEngine.getScreenPosition(gGameEngine.gPlayer0.pos).y
		    };

			// set dirVec to be the diff between player pos and
			// mouse pos then normalize the vector
			var mouse = gInputEngine.mouse;
			var dirVec = new Vec2(0,0);
			dirVec.x = playerCanvasPos.x - mouse.x;
			dirVec.y = playerCanvasPos.y - mouse.y;
		    dirVec.Normalize();

			// actually launch the thing!

		}

	- Keyboard firing your missiles (much like position move_dir)
		if (gInput.Actions['fire-up']) {
		    gGameEngine.dirVec.y -= 1;
		} else if (gInput.Actions['fire-down']) {
		    gGameEngine.dirVec.y += 1;
		}
		if (gInput.Actions['fire-left']) {
		    gGameEngine.dirVec.x -= 1;
		} else if (gInput.Actions['fire-right']) {
		    gGameEngine.dirVec.x += 1;
		}

	- Keyboard input only allows cardinal and ordinal firing relative to player position. To disallow mouse advantage (degrees of freedom), snap mouse vector to one of the 8 directions that keyboard controls allow.
		- They use a LUT (lookup table) populated with the 8 directional vectors, unitized
		- They then make a getQuantizedAngleIndex function to:
		- atan2 to find the dirVec angle in radians
		- then round and modulo that into an integer between 0-7
		- return that and use as index to find value in LUT

3. ENTITIES
	- Classes in our actual game environment. All entities should keep track of their position in the world and "think" or be able to do something each tick.
	- You have a class that makes this entity different from all the other entities in the world.

*	// Basic entity class creation in Entity.js
	// properties for individual entities, including an
	// update function that will be added to for behavior
	EntityClass = Class.extend({
		pos : { x: 0, y: 0 },
		size : { x: 0, y: 0 },
		update : function (){}
	});

	- in GameEngineClass def (the one with dirVec, move_dir, gPlayer0.pos, gPlayer0.walkSpeed), make a spawnEntity function

	GameEngineClass = Class.extend({
		// return a new instance of requested class
		spawnEntity : function (typename) {
			if (typename == "Player") {
				return new PlayerClass();
			} else if (typename == "Landmine") {
				return new LandmineClass();
			} else if (tyoename == "QuadDamage") {
				return new QuadDamageClass();
			}
		}
	});
	gGameEngine = new GameEngine();

	- This works, but what if there are dozens or hundreds of entity types? This is a large case statement. Minimal scalability.

	// Don't do the above branching. Create a factory object
	// that maps entityname to classname in a hash table
	GameEngine ...
		factory : {},
		...
	});
	gGameEngine.factory['EntityType'] = ClassDefinitionName;

	// within the refactored spawnEntity function
		spawnEntity : function (typename) {
			return new (factory[typename])();
		}

*	- Engineers often hardcode refs to assets, making artists have to talk to engineers if they want to change path / asset. With Data-Driven Design, there's a text/xml/json that allows designer and artist to iterate on without talking to someone in the pit. To change the assets they can reference a new asset there, like say a certain frame for a kick in a fighting game. You can become too reliant, though, moving most of your code "out there", which then means that small changes necessitate bringing engineers back in.

	- 