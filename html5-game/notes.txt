HTML 5 GAME DEVELOPMENT

- Welcome! There's an optional JS crash course at the end if not familiar.

0. CANVAS
(Hey, didn't I just take this? ;)
- How to write a 2d, tile-based engine: HTML5 canvas element
- Canvas as large memory blob of pixel data
	- it's an HTML5 drawing surface that exposes APIs
	- 2 attribs spec to it: width and height
- canvas.getContext('2d');
	- handle to the drawing APIs we'll use
- FULLSCREEN == window.innerWidth, window.innerHeight
- IMAGES
	1. declare Image() object
	2. define onload()
	3. set image.src
	(JS kicks off a load func once source is set!)
- canvas.drawImage(img, posX, posY) from top L corner of canvas
- jpeg for size vs png for alpha vs webp for both
- ANIMATION
	- simple flipbook:
		0. setup frame and framerate variables
		1. load an array of imgs into a frames var
			frames.push(new Image());
			frames[i].onload = // your load func ;
			frames[i].src = // your img src ;
		2. animate setInterval every say 30 ms (but last class did render frame)
		3. when you draw frames in animate func, set to loop back around:
*			frame = (frame + 1) % frames.length; 		// get it?!?
		4. add clearRect for no skinning
- Awesome story about Carmack and "Dirty Rect"

1. ATLASES
- as # images in asset set increases, ups drawing to screen complexity
- browser has upper limit on # connections available
	- if only 6 connections available and >6 requests, the other requests get stacked until something gives
	- ask for 1 big img 241 ms VS split it into 16 smaller 4 secs!
	- pack imgs together and deliver at once
- Texture Atlasing: packing smaller imgs into larger imgs
	- well-studied process in most games
	- 1 Tex Atlas contains many smaller sub-imgs each ref'd indepdtly
- vs "Spritesheets", a term originally just for animated objects
	- Atlases might be say bg tiles
	- this is a bone of contention in game dev jargon!
** TEXTURE PACKING: tricky engineering "bin packing problem"!
	- NP Hard, he uses it as an interview question
	- Atlas info in JSON format
	- list of img names (the "original LOOSE ASSET"), and for each img:
		- frame: x, y, w, h  			// the img within the atlas
		- rotated: true/false
		- trimmed: true/false
		- spriteSourceSize: {x,y,w,h} 	// for drawing to our canvas
		- sourceSize: {w,h}
*	Texture Packing Quiz
		0. Write a defSprite method that takes a (name,x,y,w,h,cx,cy)
			- center x and center y are negative offsets from w and h
			- do this here so don't have to calculate later on!
		1. Map those values to an object
		2. Add that object to a sprites array
		3. Load JSON atlas data and parse it

		4. Call the define sprites method on that json data
* drawImage - the advanced version
	- not just x,y,w,h BUT ALSO a SOURCE x,y,w,h vs a DEST x,y,w,h
	- clearly handy for outputting imgs from our atlas to our canvas!!
	- any diff in s_ -> d_ vals is handled by SCALING
		- e.g. if sx=10 and dx=5, img scaled in half along x
- We're still missing a link between artist file (loose asset) + atlas
*	FIX THIS!
		0. drawSprite function that takes name of loose asset and x,y
		1. a dictionary of all atlases and all images in spritesheets
		2. __drawSpriteInternal (sprite, sheet, posX, posY) {}
		3. drawSprite figures out what atlas this sprite was in
		4. drawSprite passes that info to __drawSpriteInternal
		5. __drawSpriteInternal heavy lifting of positioning/drawing
		* Pass in the ENTIRE SPRITESHEET to drawImage
		* draw image with axis origin at center:
			- hold off {x: posX-sprite.w*0.5, y: posY-sprite.h*0.5}
			- use those .x, .y vals when drawing positionX, positionY
- Now handle TRIMMED sprites (usually cut out alpha edges)
	0. Smart trim crops from the edges to the center. Think about this.
	1. Initialize new center x and center y vals
	2. From the sprite JSON, get the trimmed img's x y w h
	3. subtract half the height from the y, half the width from the x
		- This accounts for the cropped offset from the bottom r corner (in other words, from the w and h vals of the img)
		- Think why: geometrically, we are now moving the image "behind" its starting w h values. From now on, we can call those vals when we draw the trimmed image!
-  