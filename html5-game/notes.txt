HTML 5 GAME DEVELOPMENT

- Welcome! There's an optional JS crash course at the end if not familiar.

0. CANVAS
(Hey, didn't I just take this? ;)
- How to write a 2d, tile-based engine: HTML5 canvas element
- Canvas as large memory blob of pixel data
	- it's an HTML5 drawing surface that exposes APIs
	- 2 attribs spec to it: width and height
- canvas.getContext('2d');
	- handle to the drawing APIs we'll use
- FULLSCREEN == window.innerWidth, window.innerHeight
- IMAGES
	1. declare Image() object
	2. define onload()
	3. set image.src
	(JS kicks off a load func once source is set!)
- canvas.drawImage(img, posX, posY) from top L corner of canvas
- jpeg for size vs png for alpha vs webp for both
- ANIMATION
	- simple flipbook:
		0. setup frame and framerate variables
		1. load an array of imgs into a frames var
			frames.push(new Image());
			frames[i].onload = // your load func ;
			frames[i].src = // your img src ;
		2. animate setInterval every say 30 ms (but last class did render frame)
		3. when you draw frames in animate func, set to loop back around:
*			frame = (frame + 1) % frames.length; 		// get it?!?
		4. add clearRect for no skinning
- Awesome story about Carmack and "Dirty Rect"

1. ATLASES
- as # images in asset set increases, ups drawing to screen complexity
- browser has upper limit on # connections available
	- if only 6 connections available and >6 requests, the other requests get stacked until something gives
	- ask for 1 big img 241 ms VS split it into 16 smaller 4 secs!
	- pack imgs together and deliver at once
- Texture Atlasing: packing smaller imgs into larger imgs
	- well-studied process in most games
	- 1 Tex Atlas contains many smaller sub-imgs each ref'd indepdtly
- vs "Spritesheets", a term originally just for animated objects
	- Atlases might be say bg tiles
	- this is a bone of contention in game dev jargon!
** TEXTURE PACKING: tricky engineering "bin packing problem"!
	- NP Hard, he uses it as an interview question
	- Atlas info in JSON format
	- list of img names (the "original LOOSE ASSET"), and for each img:
		- frame: x, y, w, h  			// the img within the atlas
		- rotated: true/false
		- trimmed: true/false
		- spriteSourceSize: {x,y,w,h} 	// for drawing to our canvas
		- sourceSize: {w,h}
*	Texture Packing Quiz
		0. Write a defSprite method that takes a (name,x,y,w,h,cx,cy)
			- center x and center y are negative offsets from w and h
			- do this here so don't have to calculate later on!
		1. Map those values to an object
		2. Add that object to a sprites array
		3. Load JSON atlas data and parse it

		4. Call the define sprites method on that json data
* drawImage - the advanced version
	- not just x,y,w,h BUT ALSO a SOURCE x,y,w,h vs a DEST x,y,w,h
	- clearly handy for outputting imgs from our atlas to our canvas!!
	- any diff in s_ -> d_ vals is handled by SCALING
		- e.g. if sx=10 and dx=5, img scaled in half along x
- We're still missing a link between artist file (loose asset) + atlas
*	FIX THIS!
		0. drawSprite function that takes name of loose asset and x,y
		1. a dictionary of all atlases and all images in spritesheets
		2. __drawSpriteInternal (sprite, sheet, posX, posY) {}
		3. drawSprite figures out what atlas this sprite was in
		4. drawSprite passes that info to __drawSpriteInternal
		5. __drawSpriteInternal heavy lifting of positioning/drawing
		* Pass in the ENTIRE SPRITESHEET to drawImage
		* draw image with axis origin at center:
			- hold off {x: posX-sprite.w*0.5, y: posY-sprite.h*0.5}
			- use those .x, .y vals when drawing positionX, positionY
- Now handle TRIMMED sprites (usually cut out alpha edges)
	0. Smart trim crops from the edges to the center. Think on this.
	1. Initialize new center x and center y vals
	2. From the sprite JSON, get the trimmed img's x y w h
	3. subtract half the height from the y, half the width from the x
		- This accounts for the cropped offset from the bottom r corner (in other words, from the w and h vals of the img)
		- Think why: geometrically, we are now moving the image "behind" its starting w h values. From now on, we can call those vals when we draw the trimmed image!
- The classic tools aren't dead in HTML5!
	- can read traditional formats that you might not expect
	- important for new game devs and studios who think they have to reinvent all tools to work in HTML5
- ENVIRONMENTS: drawing the 2D map
	- have atlas that works like the sprites
*	- TILE also generates for us a large, complex data file
		- this shows how atlas should be rendered to draw bg
		- big games would have artist take this
		- here we're going to read in our json.
		- Tile tells us which atlases to load and how the layers are organized on top of each other
	0. setup an XHR
		function xhrGet(reqUri,callback) {
			var xhr = new XMLHttpRequest();
			xhr.open("GET", reqUri, true);
			xhr.onload = callback;
			xhr.send();
		}
	1. perform an XHR to load tiles
		var TILEDMapClass = Class.extend({
		    // Boolean flag set once map atlas loads
		    fullyLoaded: false,
		    load: function (map) {
		        // Perform an XMLHttpRequest to grab the
		        // JSON file at url 'map'. We've provided
		        // the xhrGet function from the optional
		        // unit for you to use if you want.
		        //
		        // Once the XMLHttpRequest loads, set the
		        // 'fullyLoaded' flag to true.
		        //
		        xhrGet(map, false, function(data) {
		            this.fullyLoaded = true;
		        });       
		    }
		});
	2. Parse the JSON file
		- initial parameters: size of tile map expects (tilew, tileh)
		- initial params: # of vert and horiz tiles used (width)
		- understand dimensions: width * tilewidth gives # pixels w
		- "tilesets": which atlases, including paths and firstgid
		- separate section devoted to layers:
			- "data": HUGE array of ints for each tile placed this lyr
			- "type": whether it's a tile lyr or an object lyr
		- Raster Scan Order: each row listed after previous row
		- Any non-zero val in data reps a tile index for a given atlas
			- That "firstgid" for each atlas in "tilesets"
			- Each atlas inside tile has its own gid
			- Tiled has own heuristic for each subsequent loaded atlas, don't worry, but be aware
			- 167 = 1st gid (atlas), tile 166 /!\
	3. Loading the tile maps (COMPLEX procss)
		- modify xhrGet to call a parseMapJSON function
		- in parseMapJSON, assign JSON.parse(mapJSON)
		- use assigned this.currentMapData to cache vals
			( kw THIS refers to gMap object the function is within )
			- avoids walking thru the JSON later on
			- first vals to care about are:
				a. num X tiles, num Y tiles
				b. size of tiles x,y
				c. pixel size of the entire map x, y
					( calc based on num tiles * size of tiles)
		- set the fullyLoaded attribute to true
*		/!\ Parse function still not working even when perfectly matches instructor solution /!\
	4. Loading tileset data described in the file
		- create a new image for each tile
		- set a callback function for once done loading
		- set the source value to the tileset's img attribute
*		- kicking off ASYNCHRONOUS loads of imgs when our map is ALREADY asynchronously loading!
		- so wait to set fullyLoaded to true until after all tilesets fully loaded into memory (use a counter val)