HTML 5 GAME DEVELOPMENT

- Welcome! There's an optional JS crash course at the end if not familiar.

0. CANVAS
(Hey, didn't I just take this? ;)
- How to write a 2d, tile-based engine: HTML5 canvas element
- Canvas as large memory blob of pixel data
	- it's an HTML5 drawing surface that exposes APIs
	- 2 attribs spec to it: width and height
- canvas.getContext('2d');
	- handle to the drawing APIs we'll use
- FULLSCREEN == window.innerWidth, window.innerHeight
- IMAGES
	1. declare Image() object
	2. define onload()
	3. set image.src
	(JS kicks off a load func once source is set!)
- canvas.drawImage(img, posX, posY) from top L corner of canvas
- jpeg for size vs png for alpha vs webp for both
- ANIMATION
	- simple flipbook:
		0. setup frame and framerate variables
		1. load an array of imgs into a frames var
			frames.push(new Image());
			frames[i].onload = // your load func ;
			frames[i].src = // your img src ;
		2. animate setInterval every say 30 ms (but last class did render frame)
		3. when you draw frames in animate func, set to loop back around:
*			frame = (frame + 1) % frames.length; 		// get it?!?
		4. add clearRect for no skinning
- Awesome story about Carmack and "Dirty Rect"

1. ATLASES
- as # images in asset set increases, ups drawing to screen complexity
- browser has upper limit on # connections available
	- if only 6 connections available and >6 requests, the other requests get stacked until something gives
	- ask for 1 big img 241 ms VS split it into 16 smaller 4 secs!
	- pack imgs together and deliver at once
- Texture Atlasing: packing smaller imgs into larger imgs
	- well-studied process in most games
	- 1 Tex Atlas contains many smaller sub-imgs each ref'd indepdtly
- vs "Spritesheets", a term originally just for animated objects
	- Atlases might be say bg tiles
	- this is a bone of contention in game dev jargon!
** TEXTURE PACKING: tricky engineering "bin packing problem"!
	- NP Hard, he uses it as an interview question
	- Atlas info in JSON format
	- list of img names (the "original LOOSE ASSET"), and for each img:
		- frame: x, y, w, h  			// the img within the atlas
		- rotated: true/false
		- trimmed: true/false
		- spriteSourceSize: {x,y,w,h} 	// for drawing to our canvas
		- sourceSize: {w,h}
*	Texture Packing Quiz
		0. Write a defSprite method that takes a (name,x,y,w,h,cx,cy)
			- center x and center y are negative offsets from w and h
			- do this here so don't have to calculate later on!
		1. Map those values to an object
		2. Add that object to a sprites array
		3. Load JSON atlas data and parse it

		4. Call the define sprites method on that json data
* drawImage - the advanced version
	- not just x,y,w,h BUT ALSO a SOURCE x,y,w,h vs a DEST x,y,w,h
	- clearly handy for outputting imgs from our atlas to our canvas!!
	- any diff in s_ -> d_ vals is handled by SCALING
		- e.g. if sx=10 and dx=5, img scaled in half along x
- We're still missing a link between artist file (loose asset) + atlas
*	FIX THIS!
		0. drawSprite function that takes name of loose asset and x,y
		1. a dictionary of all atlases and all images in spritesheets
		2. __drawSpriteInternal (sprite, sheet, posX, posY) {}
		3. drawSprite figures out what atlas this sprite was in
		4. drawSprite passes that info to __drawSpriteInternal
		5. __drawSpriteInternal heavy lifting of positioning/drawing
		* Pass in the ENTIRE SPRITESHEET to drawImage
		* draw image with axis origin at center:
			- hold off {x: posX-sprite.w*0.5, y: posY-sprite.h*0.5}
			- use those .x, .y vals when drawing positionX, positionY
- Now handle TRIMMED sprites (usually cut out alpha edges)
	0. Smart trim crops from the edges to the center. Think on this.
	1. Initialize new center x and center y vals
	2. From the sprite JSON, get the trimmed img's x y w h
	3. subtract half the height from the y, half the width from the x
		- This accounts for the cropped offset from the bottom r corner (in other words, from the w and h vals of the img)
		- Think why: geometrically, we are now moving the image "behind" its starting w h values. From now on, we can call those vals when we draw the trimmed image!
- The classic tools aren't dead in HTML5!
	- can read traditional formats that you might not expect
	- important for new game devs and studios who think they have to reinvent all tools to work in HTML5
- ENVIRONMENTS: drawing the 2D map
	- have atlas that works like the sprites
*	- TILE also generates for us a large, complex data file
		- this shows how atlas should be rendered to draw bg
		- big games would have artist take this
		- here we're going to read in our json.
		- Tile tells us which atlases to load and how the layers are organized on top of each other
	0. setup an XHR
		function xhrGet(reqUri,callback) {
			var xhr = new XMLHttpRequest();
			xhr.open("GET", reqUri, true);
			xhr.onload = callback;
			xhr.send();
		}
	1. perform an XHR to load tiles
		var TILEDMapClass = Class.extend({
		    // Boolean flag set once map atlas loads
		    fullyLoaded: false,
		    load: function (map) {
		        // Perform an XMLHttpRequest to grab the
		        // JSON file at url 'map'. We've provided
		        // the xhrGet function from the optional
		        // unit for you to use if you want.
		        //
		        // Once the XMLHttpRequest loads, set the
		        // 'fullyLoaded' flag to true.
		        //
		        xhrGet(map, false, function(data) {
		            this.fullyLoaded = true;
		        });       
		    }
		});
	2. Parse the JSON file
		- initial parameters: size of tile map expects (tilew, tileh)
		- initial params: # of vert and horiz tiles used (width)
		- understand dimensions: width * tilewidth gives # pixels w
		- "tilesets": which atlases, including paths and firstgid
		- separate section devoted to layers:
			- "data": HUGE array of ints for each tile placed this lyr
			- "type": whether it's a tile lyr or an object lyr
		- Raster Scan Order: each row listed after previous row
		- Any non-zero val in data reps a tile index for a given atlas
			- That "firstgid" for each atlas in "tilesets"
			- Each atlas inside tile has its own gid
			- Tiled has own heuristic for each subsequent loaded atlas, don't worry, but be aware
			- 167 = 1st gid (atlas), tile 166 /!\
	3. Loading the tile maps (COMPLEX procss)
		- modify xhrGet to call a parseMapJSON function
		- in parseMapJSON, assign JSON.parse(mapJSON)
		- use assigned this.currentMapData to cache vals
			( kw THIS refers to gMap object the function is within )
			- avoids walking thru the JSON later on
			- first vals to care about are:
				a. num X tiles, num Y tiles
				b. size of tiles x,y
				c. pixel size of the entire map x, y
					( calc based on num tiles * size of tiles)
		- set the fullyLoaded attribute to true
*		/!\ Parse function still not working even when perfectly matches instructor solution /!\
	4. Loading tileset data described in the file
		- create a new image for each tile
		- set a callback function for once done loading
		- set the source value to the tileset's img attribute
*		- kicking off ASYNCHRONOUS loads of imgs when our map is ALREADY asynchronously loading!
		- so wait to set fullyLoaded to true until after all tilesets fully loaded into memory (use a counter val)
		for (loop thru tilesets) {
			var img = new Image();
			img.onload = function () {
				this.imgLoadCount++;
				if (this.imgLoadCount === tilesets.length) {
					this.fullyLoaded = true;
				}
			};
			img.src = tilesets.imgURL;
		}
	5. Final parsing step: keep an array of avail tileSets
		
		- create a new object with all relevant tile attributes
		
		- map the tileset attributes from JSON to obj properties
		ts = { "firstgid":map.tilesets[i].firstgid,
		// and so on for width, height, name

		// your number of x and y tiles will need to factor in both the JSON tileset and your local properties
		"numXTiles": Math.floor(map.tilesets[i].imagewidth / this.tilesize.x),
        "numYTiles": Math.floor(map.tilesets[i].imageheight / this.tilesize.y)
        }

		- push that object to the new array tileSets
		this.tilesets.push(ts);

	6. Now find img and coord of spec tile in tileset from our array
		// create function that takes index and returns tile packet
		// tile pkt contains atlas img and x,y index for the tiel
		getTilePacket: function(tileIndex) {

			var pkt = { "img": null, "px": 0, "py": 0 };

			// tileIndex will be <= firstgid
			var i;
			for (i=0; i < this.tileSets.length; i++) {
				if this.tileSets[i].firstgid >= tileIndex {
					pkt.img = this.tileSets[i].image;
					break;
				}
			}

			// calc x and y values based on tile arrangement
			var localId = tileIndex-this.tileSets[i].firstgid;
					
			var localX = Math.floor(localId % this.tileSets[i].numXTiles);
			var localY = Math.floor(localId / this.tileSets[i].numXTiles);
			// stumped like me? It's simple geometry! For x offset in grid, all you need to find is how many tiles you are from the left (the remainder, hence modulo). For y offset in grid, all you need to know is how many groups of x you've already been over (hence the division)!

			// factor in the output tilesizes (you just have indexes)
			pkt.px = localX * this.tileSize.x;
			pkt.py = localY * this.tileSize.y;

			// good to go!
			return pkt;
		}
	7. Prepare for drawing! - which tiles to draw from parsed data
		- (Check that gMap was fully loaded)
		- Layer data in JSON file, very often 0's (no tile)
		- Loop through each layer
		- For each layer loop thru tile id's in the data of each layer
		- A significant % of them will be set to 0 (draw no tiles)
		- If tile id isn't 0, grab getTilePacket (above) with that id
		
		// ignore if the map isn't loaded yet
		if(!gMap.fullyLoaded) return;

		// variables for making my loop life easier
        lyrs = this.currMapData.layers;
        var pkt;

        // dig into each tile id within data within layers
        for (var i = 0; i < lyrs.length; i++) {
            if (lyrs[i].type === "tilelayer") {
                for (var j=0; j < lyrs[i].data.length; j++) {
                    if (lyrs[i].data[j] !== 0) {
                        pkt = this.getTilePacket(lyrs[i].data[j]);
                    }
                }
            }
        }

    8. Actually draw the tile to the game world
    	- figure out where based on the tile id and gmap tiles across
    	- figure out the x/y size of the tile
    	- combine these to set up the x/y offset from canvas origin

    	// use same x y magic from the tile packet to figure world XY
    	var worldX = Math.floor(tileIndex % this.numXTiles) * this.tileSize.x;
    	var worldY = Math.floor(tileIndex / this.numXTiles) * this.tileSize.y;

    	// Draw the image to the canvas
    	// Note this.tileSize is repeated to keep scaling same
    	/* 
    	 * If you're digging into this code, do yourself a favor and
    	 *   bring up the documentation for these 9 args!
    	 * It's basically source img, pos, scale (5 args) and 
    	 *   target pos, scale (4 args).
    	 */
    	ctx.drawImage (pkt.img, pkt.px, pkt.py, this.tileSize.x, this.tileSize.y, worldX, worldY, this.tileSize.x, this.tileSize.y);

2. INPUT
	- capture input and react to it properly
	- WASD + mouse input (or arrow keys) for turret
	- turret doesn't update until ready to fire (fire rate)
	- combinations of arrow or mouse directions for shooting diagonals
	- (Un)fair gameplay:
		- back in the day, turning down resolution or using DSL instead of dialup on Quake to get unfair advantage
		- in this game, pay attention to fairness from the get-go
		- mouse won't have extra degrees of freedom compared to keys
	- JS input data is like newspaper subscriptions
		- subscribe to a process like onMouseMove, onKeyDown, onClick
		- decide what function you'll call when that event happens
	- hook up mouse move and key down from events to methods

	// the mousemove event contains clientX, clientY coords
	// while keydown event contains a KeyID property

	function setup() {
		document.getElementById('canvas').addEventHandler('mousemove', onMouseMove);
		document.getElementById('canvas').addEventHandler('keydown', onKeyDown);
	}

	function onMouseMove(event) {
		return (event.clientX, event.clientY);
	}

	function onKeyDown(event) {
		return event.keyID;
	}

*	- Bad practice to respond to even within callback
		- Update loop and render can get out of sync, because input from browser can come at pretty much any time even after we've already made decisions for where to place everything that frame
		- Instead, we keep the input and hold it, allowing update loop to query it whenever it wants

	- Set up to handle key input

		// array for ASCII values
		var keyState = [];
    	keyState.length = 256;
    	keyState = Array.apply(this, keyState);
	    
	    // add an event handler 
	    document.getElementById('canvas').addEventHandler('keyup', funcName);
	   	document.getElementById('canvas').addEventHandler('keydown', funcName);

	    // build functions to set true on keydown and false on keyup
	    // basically both funcs set keyState[event.keyID] = t/f
	
	- Keymapping allows user-customized keys
		- variably modify what key corresponds to what action
		- instead of checking for ASCII values, query for action names
		- example would be checking for 'move-up' instead of '87'
		- create a bind function and a bindings dictionary alongside that key values dictionary
		- create an actions dictionary that maps values to true/false

		// onKeyDown now sets the action to true
		this.actions[this.bindings[event.keyID]] = true;

		// onKeyUp now sets the action to false
		this.actions[this.bindings[event.keyID]] = true;\

		// the new bind function maps keys to actions
		bind: function(key,action) {
			this.bindings(key) = action;
		},

		// make sure to avoid out of bounds errors for null actions

	- Using physics, teleportation becomes a problem
		- lack a straightforward way to pick up and move player
		- can't ignore the physics going on without confusing physics engine
		- e.g. if we move player to intersect with wall, get stuck
	
	- Instead, update the physics (velocity) so that the effect is moving the player where we want to
*		- "Teleportation issues"
		- Constrain physics through API to move properly on input
		- separate out GameEngine.js (physics) versus InputEngine.js
*		- We're using Box2d which has a Vec2 constructor

		// check for actions move-up, move-down, move-left, move-right
		if (gInputEngine.actions['move-up']){
			// adjust the move_dir vector 2
			// remember canvas! up is -y and down is y!!
			move_dir.y -= 1;
		}

		// 
		// Check that the squared length of the vector is non-zero
		if (move_dir.LengthSquared()) {
			// turn the vector into unit of length 1.0
			move_dir.Normalize();
			// adjust vector length based on player's walk speed
			// multiplies vector's components by a scalar (arg0)
			move_dir.Multiply(this.Player0.walkSpeed);
		}

		// Set the player velocity through the physics body
		gGameEngine.gPlayer0.mpPhysBody.setLinearVelocity(gGameEngine.move_dir.x, gGameEngine.move_dir.y);

	- Mouse firing your fancy missiles towards other robots
		1. Find directional vector from robot to mouse cursor in game space. Subtracting mouse position from the robot position, giving us an unnormalized Vec2
		2. Normalize this Vec2
		3. Use normalized Vec2 to find the velocity path for the projectile
		4. Now actually launch the thing (later)

		if (gInputEngine.actions.fire0 || gInputEngine.actions.fire1){

			// use provided gRenderEngine.getScreenPosition method
			// to grab player's onscreen x and y
		    var playerCanvasPos = {
		        x: gRenderEngine.getScreenPosition(gGameEngine.gPlayer0.pos).x,
		        y: gRenderEngine.getScreenPosition(gGameEngine.gPlayer0.pos).y
		    };

			// set dirVec to be the diff between player pos and
			// mouse pos then normalize the vector
			var mouse = gInputEngine.mouse;
			var dirVec = new Vec2(0,0);
			dirVec.x = playerCanvasPos.x - mouse.x;
			dirVec.y = playerCanvasPos.y - mouse.y;
		    dirVec.Normalize();

			// actually launch the thing!

		}

	- Keyboard firing your missiles (much like position move_dir)
		if (gInput.Actions['fire-up']) {
		    gGameEngine.dirVec.y -= 1;
		} else if (gInput.Actions['fire-down']) {
		    gGameEngine.dirVec.y += 1;
		}
		if (gInput.Actions['fire-left']) {
		    gGameEngine.dirVec.x -= 1;
		} else if (gInput.Actions['fire-right']) {
		    gGameEngine.dirVec.x += 1;
		}

	- Keyboard input only allows cardinal and ordinal firing relative to player position. To disallow mouse advantage (degrees of freedom), snap mouse vector to one of the 8 directions that keyboard controls allow.
		- They use a LUT (lookup table) populated with the 8 directional vectors, unitized
		- They then make a getQuantizedAngleIndex function to:
		- atan2 to find the dirVec angle in radians
		- then round and modulo that into an integer between 0-7
		- return that and use as index to find value in LUT

3. ENTITIES
	- Classes in our actual game environment. All entities should keep track of their position in the world and "think" or be able to do something each tick.
	- You have a class that makes this entity different from all the other entities in the world.

*	// Basic entity class creation in Entity.js
	// properties for individual entities, including an
	// update function that will be added to for behavior
	EntityClass = Class.extend({
		pos : { x: 0, y: 0 },
		size : { x: 0, y: 0 },
		update : function (){}
	});

	- in GameEngineClass def (the one with dirVec, move_dir, gPlayer0.pos, gPlayer0.walkSpeed), make a spawnEntity function

	GameEngineClass = Class.extend({
		// return a new instance of requested class
		spawnEntity : function (typename) {
			if (typename == "Player") {
				return new PlayerClass();
			} else if (typename == "Landmine") {
				return new LandmineClass();
			} else if (tyoename == "QuadDamage") {
				return new QuadDamageClass();
			}
		}
	});
	gGameEngine = new GameEngine();

	- This works, but what if there are dozens or hundreds of entity types? This is a large case statement. Minimal scalability.

	// Don't do the above branching. Create a factory object
	// that maps entityname to classname in a hash table
	GameEngine ...
		factory : {},
		...
	});
	gGameEngine.factory['EntityType'] = ClassDefinitionName;

	// within the refactored spawnEntity function
		spawnEntity : function (typename) {
			return new (factory[typename])();
		}

*	- Engineers often hardcode refs to assets, making artists have to talk to engineers if they want to change path / asset. With Data-Driven Design, there's a text/xml/json that allows designer and artist to iterate on without talking to someone in the pit. To change the assets they can reference a new asset there, like say a certain frame for a kick in a fighting game. You can become too reliant, though, moving most of your code "out there", which then means that small changes necessitate bringing engineers back in.

	- Update all gGameEngine entities at once, e.g. to destroy
		(I notice this matches what was done in the basic Engine.js file written by the instructor to build my OO JS class final project on top of: define entities, spawn entities, move them to an array, have a general update loop call each entity's individual update loop)

	// add array to GameEngine Class to keep track of spawned entities
	entities: []

	// mod .spawnEntity (typename) {} to push to that array
	// GameEngine update function {
		var ent = new (gGameEngine.factory[typename])();
		gGameEngine.entities.push(ent);	// new code!
		return ent;
	// }

	// and iterate over them (watch your scoping! you forgot "this."!)
	for (var i=0; i < this.entities.length, i++) {
		this.entities[i].update();
	}

	- Update Each Entity. Since you're now calling update functions for each entity, make sure they have update() and they're doing what you expect within update().

	// LandMineDiskClass will be a subclass of WeaponInstanceClass.
	// It will wait for an unknowing robot to walk on top of it.
	// (note that we haven't yet written the Physics Engine)

	LandMineDiskClass = WeaponInstanceClass.extend ({
		lifetime: 100,

		// METHOD OVERRIDE parent's death func
		kill: function () {
			// disable physics on this thing then destroy it
			gPhysicsEngine.removeBodyAsObj(this.physBody);
			this.physBody = null;
			gGameEngine.removeEntity(this);
		},

		update: function () {
			if (this.lifetime <= 0.0) {
				this.kill();
				return;
			}
			this.lifetime -= 0.05;
*			// after local update still call parent's update
			this.parent();
		}
	});

	- Killing entities
	// add a flag to entity to let renderer know whether killed
	_killed : false,

	// now move to GameEngine update() entities loop to check flags
	if (this.entities[i]._killed===false) this.entities[i].update();

*	- Who gets killed in what order? Order of Operations.
	- Most RTS as just allow damage to happen blindly, but...
	- ... they make sure all clients have SAME order of ops

	- Or bucketize/group order (1st infantry, 2nd tanks, 3rd bullets)
	- But then things can have upper hand on same update.

	// add a _deferredKill array to GameEngine
	_deferredKill: [],

	// in update, walk through and deal with each entity
	    for (var i=0; i<this._deferredKill.length,i++) {
            var ent = this._deferredKill[i]; // do something with it
            // then remove from entities
            this.entities.splice ( this.entities.indexOf(ent) );
        }
        this._deferredKill = [];

        // this just in! use .ERASE on lists with deferredKill[i] :!!

*	- EntityClass Render 
    // add current spritename string variable as class property
    EntityClass = Class.extend({
    	...
    	currSpriteName : null,

    	update : function() {},

    // add a draw func that uses string to fetch atlas info for sprite
    // and calls canvas.drawImage(...)
        draw : function () {
        	if (this.currSpriteName !== null) {
        		// see centering math above - I think it's like this
            	canvas.drawImage (this.currSpriteName, this.pos.x.round()-this.size.x, this.pos.y.round()-this.size.y);
        	}
        	return;
        }
    });

*	- Z INDEX to remedy entities rendering above/below others
	// property within EntityClass
	EntityClass = ...
		zindex : 0,
	...

	// then modify GameEngine's .DRAW() to BUCKET BY ZINDEX

		// first draw map
		this.gMap.draw(null);

		var fudgeVariance = 128;	// more or less in view
		zindexArray = [];
		
		this.entities.forEach(function(ent) {

			// don't draw if not in vies
			if (ent.pos.x >= gGameEngine.gMap.viewRect.x - fudgeVariance && ent.pos.y >= gGameEngine.gMap.viewRect.y - fudgeVariance) {

				// arrange entities
				// 	/!\ SOLVE - there could be multiple with		// 	same zindex! This doesn't handle that!

                if (!zIndex_array.indexOf(entity.zindex)) {
                    entities_bucketed_by_zIndex[entity.zindex] = entity;
                    zIndex_array.push(entity.zindex);
                }
            }
        });

        // Draw each entity in turn, already sorted by zIndex
        for (var i = 0; i < zIndex_array.length; i++) {
            entities_bucketed_by_zIndex[i].draw();
        }

4. PHYSICS
	- Brute force of making things collide: for every pixel, check if every other pixel of the other object is where this pixel is.
*	- Approximation instead: AXIS-ALIGNED BOUNDING BOX
	- AABB collisions account for min(x,y) & max(x,y) only
		// compare 2 rects each having a .top, .bottom, .left, .right
		intersectRect : function (r1, r2) {
			return !( r2.top > r1.bottom ||
				r2.bottom < r1.top ||
				r1.right < r2.left ||
				r1.left > r2.right );
		}
*	- getting data out of AABB collisions (LOCATION)
		- anywhere that two overlap is a good choice for point
		- which you choose can impact how rest of collision mgmt works
*	- Imagine you have a bullet that updates in 2 timesteps, going fast enough that it would miss wall bounding box between the 2. How calculate?
		- draw a "swept area" to capture things in the path between 2 timesteps!

		- IF you want to answer questions like these ("down the rabbit hole"), write your own physics engine. Otherwise use one that's already up and working. maybe open source!

		- Wish list! Want the engine to:
			- create physics objects for entities
			- update physics every frame (take care of the work)
			- fire of collisions and respond to them arbitrarily
			- pull updated pos info each obj each frame (feed to rendering engine for drawing)

*		- Enter Box2D. Written C++, then Flash AS! Now ported to JS.

	- the core of box2D is World(), main handle to rest of APIs
		- takes vector2 that represents the gravity of the world (0 if don't need)
		- takes object sleep boolean to allow for sleeping

	// a bunch of Box2D assignments up here
	Vec2 = Box2D.Common.Math.b2Vec2;
	BodyDef = Box2D.Dynamics.b2BodyDef;
	Body = Box2D.Dynamics.b2Body;
	//...

	PhysicsEngineClass = Class.extend({
		world: null,
		create: function () {
			this.world = new World (
				// top-down game, not using gravity
				new Vec2(0,0),	// empty gravity vector
				false			// don't allow sleep
			);
		}
	});

	var gPhysicsEngine = new PhysicsEngineClass();

*	- update using world object with world.Step
	- .Step takes:
		1. 	framerate for physics updates
		2. 	num velocity iterations to calc
		3. 	num position iterations to calc
	- calculating more iterations allows us to do things that can't be done in one pass (like checking if freeing us from one collision will put us into another), but is more costly. It's the performance / perfection tradeoff here
	
	update: function () {
		var start = Date.now();

		this.world.Step (	// bound in PhysicsEngine instance
			// see param info in above notes
			1.0/60.0,
			10,
			10
		);

		// added to reset physics
		// erases and removes velocity vector for less glidey,
		// airhockey-like feel to movement in our top-down game
		this.world.ClearForces();

		return (Date.now() - start);
	}

*	- Box2D is created, but now we need Physics Bodies to the world to simulate entities properly
		1.  create a body definition object
		2. 	set params (dyn/static, etc.)
		3.  register body with this.world.createBody();
		4. 	use that handle to the obj to refer to the physbody
		5.  set the physics properties with Fixture Definitions
			- friction, density, restitution are handled here
			- usu objects in a world resemble similar characteristics
			- group objects using flags to set oddballs
				// e.g. we have a bouncy bullet
				if (entityDef.useBouncyFixture) {}
		6.  set the fixture using e.g. SetAsBox method
		7. 	go play with it!
		X.  We're using Box2D. Think about other engines. They often have a whole suite of bodies. They give performance bonuses to simple ones like squares, cubes and spheres. Polygons are an option but cost in performance, so use only as needed.

	// Add body within PhysicsEngine object

	registerBody: function (bodyDef) {
        var body = this.world.CreateBody(bodyDef);
        return body;
    },

    addBody: function (entityDef) {
        // Create a new BodyDef object
        var bodyDef = this.word.BodyDef();

        var id = entityDef.id;
        
        // set body as static or dynamic
        if (entityDef.type == 'static') {
            bodyDef.type = Body.b2_staticBody;
        } else {
            bodyDef.type = Body.b2_dynamicBody;
        }

        // Set the position based on 
        // passed-in entityDef object.
        bodyDef.position.x = entityDef.x;
        bodyDef.position.y = entityDef.y;

        // Attach it to our world w above func
        var entityBody = this.registerBody(bodyDef);

        // Create a new FixtureDef object
        var fixtureDef = new FixtureDef();

        if (entityDef.useBouncyFixture) {
            // Use a bouncy 'density', 'friction', 'restitution'
            fixtureDef.density = 1.0;
            fixtureDef.friction = 0;
            fixtureDef.restitution = 1.0;
        }

        // Create a new PolygonShape object
        fixtureDef.shape = new PolygonShape();

        // Set shape with SetAsBox, which takes half the
        // width and half the height of the box as parameters.
        fixtureDef.shape.SetAsBox (entityDef.halfWidth, entityDef.halfHeight);

        // Attach the fixture to your BodyDef object.
        entityBody.CreateFixture (fixtureDef);

        // Return your BodyDef object.
        return entityBody;
    }


   	- Destroy the body

   	removeBody : function (object) {
   		this.world.DestroyBody (object);
   	}

   	
*   - Using above methods, allow Entities to have physics body

  	 	// add a handle in specific entity class in case it needs one
  	 	physBody : none,
  	 	lifetime : 0,

  	 	// now inside  init: function() {
  	 	// fill out entity def and pass into the above method
  	 	var entityDef = {
  	 		id : "EntityTypename" + guid,
  	 		x : startPos.x,
  	 		y : startPos.y,
  	 		halfWidth : this.width*0.5,
  	 		halfHeight : this.height*0.5,
  	 		damping :  	// integer property vals dampening, friction, etc.
  	 	}

  	 	// 
  	 	this.physBody = gPhysicsEngine.addBody (entityDef);


  	- Now you have to query the physics engine results through the physics bodies in order to update the entities!
* 		- ensures visual rep of obj matches physics engine representation
		- remember we inherit a .pos from general entity superclass

		// within specific entity's update property

		update: function () {
        	
        	this.lifetime -= 0.05;
        	if(this.lifetime <= 0) {
            	this.kill();
            	return;
        	}

			// Set this entity's pos thru the physBody
        	if (this.physBody !== null) {
        		this.pos = this.physBody.GetPosition();
        	}

        	this.parent();
    	}


    - Setting position of physics object
    	- use .SetPosition for teleport, as ignores intervening collisions
    	- use .SetInitialVelocity to simulate and update as expected
    	- do setting each frame to ensure things go smoothly!

    	// within specific entity's init method
    	var physVec = new Vec2(this.dir.x*this.speed,this.dir.y*this.speed);
    	this.physBody.SetLinearVelocity (physVec);

* 		// do the same within entity's update to reboot each frame!

*	- Now put it together to DRIVE the engine from our GameEngine class
		// we have Phys Engine (init/update/add/delete)
		// we have entities that can add phys bodies and update them
		// 

		0.  Create the Physics Engine in the GameEngine's .setup
		1.  Define number of physics updates we want per frame
		2.  Inside GameEngine update, call the physics engine .update

		// basic property in GameEngine
		PHYSICS_UPDATES_PER_SEC: 60,

		// inside GameEngine's .setup
			this.physEngine = gPhysicsEngine.create();

		// inside GameEngine's .update
			this.physEngine = gPhysicsEngine.update();


	- What to do when a collision happens?
		- Box2D onCollision callback given to physics bodies that touch
		- to receive these callbacks:
			0. Go to physics class
			1. Create wrapper function to listen for calls
			2. Build listener in that func that takes in callbacks
				- define logic to issue callback to those functions once the engine hits that point
				(e.g. if callbacks.PostSolve method exists, then define postsolve on the listener)
				- give the callback the two bodies that contacted
			3. Add this listener to the world (bake into world)
				- now anytime get these collision objects, get these callbacks
		- Having the collided physics body is good, but it lacks specific info that allows us to react with our game logic. Therefore, we need a way to correlate a body to an entity that created that body.

		- Could create hash tables to solve this. OR could use Box2D's handy little userData property. Assign to bodies, that way each body will have a pointer to its owning entity!

			0.  open physics class
			1.  assign userData if userData was passed in as part of assigning and registering body

		// inside the class, inside add body func
		AddBody : function (entityDef) {
			...
			if (entityDef.userData !== null) {
				bodyDef.userData = entityDef.userData;
			}
			...
		}


	- Now go back and update any Entity that creates a physBody
		
		// metadata we can later use for collisions
		userData : {
			// ref back to this Entity
			ent :  this,
			// add unique index to entity tag
			id  :  this.id+guid 	// this.id is like "Projectile"
			// be specific if necessary, like if this is a projectile
			// from a weapon, can name wpnSimpleProjectile+guid
		}

		// most importantly, it's a "this" obj that points
		// back to the entity and its useful properties (this.id!)


	- We now have to define the callbacks somewhere

	// inside GameEngine
	setup : function () {
		gPhysicsEngine.create();
		gPhysicsEngine.addContactListener ({
			
			/**  Make better!
			 *	 Check for existence/null of bodies and methods here
			 */
			PostSolve : function (bodyA, bodyB, impulse) {
				var collObjA = bodyA.GetUserData().ent;
                var collObjB = bodyB.GetUserData().ent;
                // assumes you have an onTouch method in entity
                // null here is standing for a position
                collObjA.onTouch (bodyB, null, impulse);
                collObjB.onTouch (bodyA, null, impusle);
			}
		});
	}
	// expect any entity should now define onTouch method


	- let's build out that onTouch function called in GameEngine

	onTouch : function (otherBody, point, impulse) {
		// make sure you have a physBody to collide with
		if (!this.physBody) return false;

		// make sure the other guy has a physBody and can tell us
		// who it belongs to
		if (otherBody === null || !otherBody.GetUserData()) {
			return false;
		}

		// store entity reference we created a couple sections ago
		var physOwner = otherBody.GetUSerData().ent;

		// now do the actual physics stuff. Commonly:
			// - 1 - some control flow and calculations
			// - 2 - then, call funcs, like .dealDamage or whatever
			// - 3 - finally, set flags, like this.markForDeath=true;

		/*
		 *	/!\ WHEN WRITING this function or similar, PLEASE
		 * 		remember what the entities are and keep big pic
		 * 		in mind of how behaving in world. Notetoself
		 */

		return true;
	}


	// simple example in practice: an Energy Canister (in class)

	onTouch: function (otherBody, point, impulse) {

		// checks explained in model code above
        if(!this.physBody) return false;
        if(!otherBody.GetUserData()) return false;

        // assignment explained in model code above
        var physOwner = otherBody.GetUserData().ent;

        if(physOwner !== null) {
        	// check collided obj for pulse
            if(physOwner._killed) return false;

            // canister increases 'energy' property of 'physOwner'
            physOwner.energy += 10;

            // or BETTER
            if (physOwner.energy < physOwner.maxEnergy) {
            	physOwner.energy = Math.min (physOwner.maxEnergy, physOwner.energy + 10);
            }

            // or BEST (assuming .addHealth exists and does checks)
            physOwner.AddHealth (10);

            // destroy canister
            this.markForDeath = true;
        }
        return true;
    }


5. SOUND
	// so you can hear the zombies chasing you

	- using audio APIs for web to make game clearly stand out

* - How Web Audio Works
	- As analog signal that gets digitized and then
	- can be run through series of nodes for fx
	- visualize this with the website Web Audio Playground app
	- this is called an Audio Context. everything in it runs on code

	- We will be playing basic sound clips and adjusting vol based on game state, e.g. distance from player

	- However, you might want more fx like doppler fx

*	- When grab sounds from various sources, they won't be unified
*	- run them through POST-PROCESSOR!

	// create a new SoundManager
	var SoundManager = Class.extend({
		clips : {},			// obj not array so can still query by url
		enabled : true,		// whether to play sounds
		_context : null,	// the webkitAudioContext object
		_mainNode : null	// primary audio node in this context
	});

	var gSM = new SoundManager();


*	- Audio nodes experimental & webkit only.

	// Catch any exceptions on webkit audio initialization
	// within SoundManager
	create: function () {
		try {
			this._context = new webkitAudioContext();
		} catch (e) {
	        window.alert("Your browser does not support Web Audio API. The audio in this game may not work as designed.");
		}

*		// now create and set up a node through the context
		this._mainNode = this._context.createGainNode (0);
*		// connect the node to audio destination (usu speakers)
		this._mainNode.connect (this._context.destination);
	}


*- Audio LOADING
	- Async similar to imgs on canvas
	- Check if sound is loaded. If is, call callback func
	- If it's NOT loaded, kick off a load:
		- kick it off in form of XHR xml-http request
		- then assign callback function for once load complete
	- Return actual click data either way
	
	loadAsync : function (path, callbackFn) {}
	
		// check if the clip's already there and run the function
		if (this.clips[path]) {
			callbackFn (this.clips[path].s);
			return this.clips[path].s;
		}

		// clip has an audio obj, buffer val and an isloaded boolean
		var clip = {s: new Sound(), null, false};

		// add clip to the clips object for this class
		this.clips[path] = clip;

		clip.s.path = path;

		// fire off XML request
		var request = new XMLHttpRequest();
		request.open('GET', path, true);

		// the response won't be text but an array buffer
		request.responseType = 'arraybuffer';

		// decode the array buffer using .decodeAudioData
		request.onload = function() {
			this._context.decodeAudioData(request.response,
				// store buffer into the clip
				function(buffer) {
					clip.b = buffer;
					clip.l = true;
					callbackFn (clip.s);
				},
				function (data) {
					Logger.log("failed");
				});
		}
		
		return clip.s;
	}


*	- PLAY the sound. Create a play method that handles the settings dictionary and checks and then plays through the object.

	playSound : function (path, settings) {
		// Check if the Sound Manager has been enabled
		if (!this.enabled) return false;

		// Set default values for looping and volume.
		var looping = false;
		var volume = 0.2;

		// Check for volume and looping, then update those
		if (settings) {
			if (settings.looping) looping = settings.looping;
			if (settings.volume) volume = settings.volume;
		}

		// Check if the path has an associated sound clip,
		// and whether the sound has been loaded yet.
		var sd = this.clips[path];
		if (sd === null) return false;
		if (sd.l === false) return false;

		var currentClip = null;

		// use context to create buffer source for the sound
		currentClip = this._context.createBufferSource();
		
		// Set the properties of currentClip
		currentClip.buffer = sd.b;
		currentClip.gain.value = settings.volume;
		currentClip.loop = settings.looping;
		
		// Connect currentClip to the main node, then play now (0)
		currentClip.connect(this._mainNode);
		currentClip.noteOn(0);

		return true;
	}

*	- STOP playing by disconnecting node from main node
	
	stopAll : function () {
		this._mainNode.disconnect();
		
		// Create a new GainNode inside our context.
		this._mainNode = this._context.createGainNode(0);

		// Connect it to context's audio 'destination'.
		this._mainNode.connect (this._context.destination);
	}

*	- MUTE by setting value of gain node

	togglemute : function () {
		// BETTER YET! - remember old vol and set back to that
		var gain = this._mainNode.gain.value;
		if (gain > 0) this._mainNode.gain.value = 1;
		this._mainNode.gain.value = 0;
	}


	- Now we want to attach sounds to entities so they can play on events. Create a sound object for this.

Sound = Class.extend({
	path: "",

	play: function(loop) {
		// Call the playSound function with the Sound object's path
		// Remember to pass loop & vol as a settings dictionary.
		gSM.playSound (this.path, {volume: 1, looping: loop});
	}
});

function playSoundInstance(soundpath) {
	// Load a new Sound object using loadAsync.
	// Call sound object's .play in the callback to loadAsync
	gSM.loadAsync (soundpath, function(sObj){sObj.play(false);} );
}


*	- GAME ENGINE PLAY sounds and adjust them on the fly.
	- distant explosion sounds fainter than health pickup right here
	- Distance calculation based on view rect size. Screen radius sounds at full vol, scale down to 0 as reach 2x radius.

	// within GameEngine class
    playWorldSound: function (soundURL, x, y) {

        // First we check if the player exists. If not, then we
        // don't need to bother playing sounds.
        if (gGameEngine.gPlayer0 === null) return;

        // We set a shorthand for gGameEngine.gMap for ease of use.
        var gMap = gGameEngine.gMap;

        // Grab the maximum of half width and height of viewRect
        var viewSize = Math.max(gMap.viewRect.w,gMap.viewRect.h)*0.5;

        // Grab the player's position.
        var oCenter = gGameEngine.gPlayer0.pos;

        // Distance from player position to sound position
        distX = Math.abs(oCenter.x-x);
        distY = Math.abs(oCenter.y-y);

        // Normalize distance from player to the sound by screens
        var distScreensAway = Math.max(distX,distY)/viewSize;
        
        // set sound based on distance from player
        var vol;
        if (distScreensAway < 0.5) {
        	vol = 1.0;
        } else if (distScreensAway < 1.0) {
        	vol = 0.5;
        } else {
        	vol = 0.0;
        }
 
        // Play sound using load and callback we wrote earlier 
        gSM.loadAsync (soundURL, function(sObj) { gSM.playSound(sObj.path,{volume:vol,looping:false}); } );
        
    }


    - Note that sound design can be expensive and require lots of retooling at every change. Usually saved for end of pipeline.


6. ASSET LOADING
	- Get it right, games load quickly. Wrong, bad load times.
	
	// we've already done this
	var img = new Image();
	img.onload = function () {
		// do sth and return;
	}
	img.src = "";

	- as things get complex, need more flexibility
	- Might be fetching from web every time. What if could just check for and return the in memory version?
	- This sets us down the path to Asset Loading Manager
	- All are async, so don't need to put together all the logic of communicating between threads. Just use callbacks once loaded.

	- Asset Manager:
		0. cached asset management (for loaded so no reloads)
		1. async callbacks once asset loaded
		2. batched asset loading (heterogenous file computation e.g. map loading)


*	- CREATE and CHECK CACHE before loading images

	function loadAsset (assetName, callbackFcn) {
		// if image exists, run the callback on it
		if (assetName in gCachedAssets) {
		    callbackFcn (gCachedAssets[assetName]);
		}

		// load the new image
		var img = new Image();
		img.onload = function () {
			callbackFcn(img);
		};
		img.src = assetName;

		// Add the new asset to the cache.
		gCachedAssets[assetName] = img;
	}


	- When upload a suite of files, have callback for each one. Instead, have a list of files and get one callback once all loaded.

// modify to take a list of asset names
var gCachedAssets = {};

function loadAssets(assetList, callbackFcn) {
	//
	// Load each element of assetList. The elements
	// of assetList will be strings representing asset
	// names. Call the callback only once ALL images
	// are loaded.
	//
	var batch = {
	    count : assetList.count,
	    progress : 0,
	    callback : callbackFcn
	};
	
	for (var i=0; i<assetList.count; i++) {
        assetName = assetList[i];
        
        // image is cached - check if all loaded and issue callback
    	if (assetName in gCachedAssets) {
    		batch.progress += 1;
            if (batch.progress == batch.count) batch.callback(gCachedAssets[assetName]);
        
    	} else {
    	    // load image, cache it and run callback if all imgs loaded
    		var img = new Image();
    		img.onload = function () {
    			batch.progress += 1;
    			if (batch.progress == batch.count) batch.callback(img);
    		};
    		img.src = assetName;

	    	gCachedAssets[assetName] = img;
    		
        }
	}
}


	- Extend beyond imgs. Determine type of asset trying to load

function getAssetTypeFromExtension(fname) {
	if(fname.indexOf('.jpg') != -1 || fname.indexOf('.jpeg') != -1 || fname.indexOf('.png') != -1 || fname.indexOf('.gif') != -1 || fname.indexOf('.wp') != -1) {
		// It's an image!
		return 0;
	}

	if(fname.indexOf('.js') != -1 || fname.indexOf('.json') != -1) {
		// It's javascript!
		return 1;
	}

	// Uh Oh
	return -1;
}

	// then in the check if file in cache from last section
	...
		// IF assetList[i] isn't in gCachedAssets :
			...
			var assetType = getAssetTypeFromExtension(assetList[i]);

			// do image load stuff just like before
			if (assetType === 0) {
				...
			}
			// it's a script; add to the DOM
			else if (assetType === 1) {
				var el = document.createElement("script");
				el.setAttribute("type", "text/javascript");
				el.addEventListener("load", function(e){
					onLoadedCallback(el, loadBatch);
				}, false);
				el.setAttribute("src", assetList[i]);
				document.getElementsByTagName("head")[0].appendChild(el);
				gCachedAssets[assetList[i]] = el;
			}


*	- Just like old days of single-thread loading CD ROMS, users on slow connection will have trouble both loading and rendering UI to screen. Extending ASYNC methodology to menus/UI, we can nip this problem in the bud
	PHASE 1.  Menu data. First screen. Load immediately.
		- handled by: browser's page parser and handler
	PHASE 2.  load scripts when user hits "join game"
		- handled by: undefined by DOM, so issue fetch to AssetLoader and wait until it's been loaded.
		/!\ Game scripting and menu scripting are two separate code bases, so loaded separately as well.
	PHASE 3.  Load subsequent assets. Good practice to do this after scripts have come in!
	PHASE 4.  LOADED! Turn off the UI and show the canvas element.

	initialLoad.js

	var inputScripts = [
		"./scripts/core/core.js",
		"./scripts/core/GameEngine.js"
	];

	AssetLoader.loadAssets (
		inputScripts,
		function(){
			window.alert("All files have been loaded.");
		}
	);


* PROPER ASSET LOADING * - a note about UX
If you have streaming loading overhead, need something to cover that from the user. Animation, whatever.
Famous examples:
	- Devil May Cry: while loading, do damage to loading bar
	- Metroid Prime: tunnel shooter, so next tunnel loads when get near end and shoot the door. However, if run too fast, sit there shooting the door but next level hadn't loaded yet!
	- Jak & Daxter: infinite terrain, but if area not loaded, your player tripped and played getup animation.
Most GameDev is smoke and mirrors!
Write an asset loading tool. Throughout game dev career, constantly fighting to load more and more data faster into less and less memory.


7. XTRA JS MINICOURSE

	// Create an object using Object Literal Notation
	var RenderEngineClass = {
		// creating a function
		propertyName : function () {
			// statements
		}
	};

	// Access through dot notation
	var ctx = gRenderEngine.context;
	ctx.font = ...
	
	// IF statements and FOR loops
	
	// single line
	if (condition == True) do that;
	for (var i=0; i<n; i++) doThatTo(i);
	
	// multi line
	if (condition === True) {
		do that;
	}
	for (var i=0; i<n; i++) {
		doThatTo(i);
	}


	// JSON formatted objects
	var parsed = {
		"frames": {
			"chaingun.png" : {
				"frame" : {
					"x" : 600,
					"y" : 400,
					"w" : 50,
					"h" : 40
				},
				"rotated": false,
				"trimmed": true,
				"spriteSourceSize": {
					...
				},
				"sourceSize": {
					...
				}
			},
			...
		}
	};

	// Parse JSON
	parseJSON = function (weaponJSON) {
		
		// Do the actual parsing
		var parsed = JSON.parse(weaponJSON);

		// Assign and access properties
		var chaingun = parsed['frames']['chaingun.png'];
		console.log (chaingun.spriteSourceSize.x);
	}


	// XMLHTTPRequest to retrieve JSON from server
	// specify URL and function call on response
	// 	1.  Create new XMLHttpRequest() Object
	//  2.  xhr.open("GET","URL",async)
	//  3.  xhr.onload = function(){}
	//  4.  xhr.send()

	var setup = function() {

	    var xmlhttp = new XMLHttpRequest();
	    xmlhttp.open("GET","/....png",true);

	    // Access the JSON response with the this kw
	    xmlhttp.onload = function() {
	        var parsedJSON = JSON.parse(this.responseText);
	        ...
	    }

	    xmlhttp.send();

	};


	// Loading sound using XHR with arraybuffer
	// specifies this is binary rather than text

	var setup = function() {

		// arraybuffer so browser doesn't think it's text
		// and slow to a crawl and crash

		var soundRequest = new XMLHttpRequest();
		soundRequest.open ('GET','/files/sound.ogg',true);
		soundRequest.responseType = 'arraybuffer';

		// and now the .load and .send
		// note load is doing audio node stuff learned earlier

		soundRequest.onload = function () {

			try {
				var context = new webkitAudioContext();

				var mainNode = context.createGainNode(0);
				mainNode.connect(context.destination);

				var clip = context.createBufferSource();

				context.decodeAudioData(soundRequest.response, function (buffer) {
					clip.buffer = buffer;
					clip.gain.value = 1.0;
					clip.connect(mainNode);
					clip.loop = true;
					clip.noteOn(0);
				}, function (data) {});
			}
			catch(e) {
				console.warn('Web Audio API is not supported in this browser');
			}
		};

		soundRequest.send();
	};


*	// Abstract out XHR into function
	// and run it from playsound, parsejson and other methods!
	function xhrGet (uri, callback, type) {

		// store who called this method for error logging
		var caller = xhrGet.caller;

		var xhr = new XMLHttpRequest();
		xhr.open ('GET', uri, true);

		// it's text if null, binary if arraybuffer
		if (type) xhr.responseType = type;

		// run callback
		// assume callback takes xhr response as param
		xhr.onload = function () {
			if (callback) {
				try {
					callback (xhr);
				} catch (e) {
					throw 'xhrGet failed: \nCaller: ' + caller + '\nError:' + e;
				}
			}
		};

		xhr.send();
		return xhr.response;
	}

	// better yet: catch errors on type, load and xhr.caller


	// DOM - selecting, creating and inserting
	document.getElementById("exampleform").onsubmit = function () {
		var notify = document.getElementById("notify");
		if (notify === null) {
			notify = document.createElement ("p");
			notify.textContent = "Some text!";
			notify.id = "notify";
			var body = document.getElementsByTagName("body")[0];
			body.appendChild(notify);
		}
	};


	// Grab the body and create a canvas inside it

	var manipulateDOM = function() {
		var body = document.getElementById("body");
		var div = document.createElement("div");
		div.id = "gameContent";
		var canvas = document.createElement("canvas");
		canvas.id = "gameCanvas";
		div.appendChild(canvas);
		body.appendChild(div);
	};


	// Classes for "faking" traditional OO inheritance
	Weapon = Class.extend({
		init: function () {
			this._super();
		}
	});
	Bazooka = Weapon.extend({
		init: function () {
			this._super();
		}
	});