{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww11380\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\b\fs24 \cf0 Databases
\b0 \
- in memory (ephemeral, like program vars) vs.\
durable storage:\
	- key-value store\
	- navigational DB\
	- relational DB\
		- not just store, but flexible tools for querying and summarizing\
		- constraints: rules to ensure changes to data are consistent\
\
- all values in a column have same type, but also same meaning\
	- string or int data has different meanings in different columns\
\

\b Tables
\b0 \

\b HEADER
\b0  - table name and names and types of columns\

\b VALUES
\b0  - data in rows\

\b Aggregation
\b0  - doing things with data values in multiple rows, e.g. Counting, min, max, avg\
\
Running a query against database still returns a table. Tells how many rows.\
	- use \'91as X\'92 to name the returned table (instead of ?\'92s)\
\
Database usually has multiple tables in it.\
\
Things in different tables can refer to same thing. But they\'92re different kinds of sentences.\
	- ids get referenced because of possible duplicate strings or other values\
	- 
\b uniqueness
\b0  of keys = numerical ids (most database systems can do this for you)\
	- 
\b primary key
\b0  - way of identifying. Some things (like countries) are unique and id\'92able by name\
\

\b Join
\b0  to derive new result table from existing tables.\
	- think about the kind of data you\'92d need to join when structuring each table\
\

\b SQL basics
\b0 \
- datatypes are complicated and have different names and distinctions than scripting langs\
	- Strings: text type, but others exist like char and varchar\
	- Numbers: int type, etc.\
	- Date and Time types - have to put SINGLE QUOTES!! 2012-11-23 is an integer expression\
- Query formula:\
	- SELECT (data) FROM (tables) WHERE (col-x = \'91value\'92 AND col-y = \'91value\'92)\
- Comparisons = < > != >= <=\
\
- SQL is tough/varied with respect to table columns and rows listed in a standard way. \
\

\b SQL select clauses and adjusting returns
\b0 \
*			select all\
order by		choose field to order results\
asc/desc		after order by\
limit x			how many results to return\
offset n		how far into results to start\
min/max(field)	return smallest/largest value for column\
group by		combines rows into summary rows for aggregates (instead of individual rows)\
			- only with aggregations like count, sum\
as			gives column a name\
\
Why not just do work in script lang?\
- count is like length, and limit is like slicing, and order is like key:val, BUT\
- SPEED and SPACE. Python can take 1 sec to go thru 1 million items. SQL is faster.\
- the big speedup is 
\b INDEXING
\b0 . not so much this course, but look it up!!\
\

\b SQL adding to table
\b0 \
- INSERT into table(col1,col2) values(\'911', \'922\'92)\
- column names are optional, unless you just want to add those specific columns\
- Inserts are simple, and just add a row to a table\
- UPDATE table SET column=value WHERE restriction;\
	- like select, without WHERE restrictions it applies to every row (not usu desirable here!)\
	- WHERE content LIKE \'91%string%\'92;	lets you match pattern, e.g. in long strings\
\

\b SQL JOIN
\b0 \

\i select T.thing, S.stuff from T join S on T.target = S.match
\i0 \
OR you can do it simply (and more commonly in real code):\

\i select T.thing, S.stuff from T, S where T.target = S.match
\i0 \
\

\b Aggregating
\b0 \
Note that when you
\b  count(*) as col_name
\b0 , you CANNOT where col_name=n\
	- the value of col_name comes from COUNT and GROUP BY, but\'85\
	- WHERE always runs before aggregations, on the underlying tables\
	- SOLUTION: use 
\b having
\b0  as easy way to run after. 
\b Subselects
\b0  are more complex, but work\
Use GROUP BY col 
\i before
\i0  HAVING aggregate_col\
\

\b Opening up the Database Black Box with Python
\b0 \
- SERVERS <-> PYTHON CODE <\'97DB-API METHOD CALLS \'97> SQLITE <\'97> DATA\
- Systems (eg. SQLite, PostgreSQL, MySQL) all have different DB-API modules. Here psychopg2\
\
import 
\i dbapi_name
\i0 \
conn = dbapi_name.connect(\'93Session_Name\'94)\
cursor = conn.cursor()\
cursor.execute (\'93query\'94)\
# if query inserts, run this\
conn.commit()\
results = cursor.fetchall()\
conn.close()			# always close your connections! stale connections take up resources\
\
Cursor can .execute(query), fetchall, fetchone\
Connection can commit() or rollback() if make changes\

\b Atomicity:
\b0  the change happens as a whole or it does not happen!\
\
Browsers use SQL database to store cookies and web history\
\
\

\b Using remote terminal to edit database
\b0 \
- VM, vagrant, then git clone it\
- go to vagrant dir\
	- vagrant up\
	- vagrant ssh\
- now you can psql\
	- psql dbname	# .sql database to work on\
	- now type sql\
	- \\d posts		# see the types the columns are along with their names\
\

\b ERRORS AND ATTACKS
\b0 \
- output sanitization: store whatever user sends as is, just make sure it can\'92t get out to harm others\
- input sanitization: clear out bad data before it ever gets into my database.\
	- when implemented, still must clean out any bad data already in database\
\

\b Sanitizing inputs against SQK injection attacks
\b0 \
- use python %s string insertion with sql insert statements\
- make sure the inserted string var is part of a tuple (string_varname,)\
- documentation warns NEVER to use + concatenation or % interpolation on strings alone here!\
\

\b Script injection attacks
\b0 \
- your db may see it as text but avoid the browser seeing it as script\
- use BLEACH for python (can install with pip)}