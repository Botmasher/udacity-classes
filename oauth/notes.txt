0. Background
	- using version of Flask restaurants app like one built for FSF
	- will be provided the above app
	- build on JS, Ajax, jQuery courses as well as Python and Flask
	- will be restricting access to authenticated users
	- need FB and G+ accounts to do the exercises
	- won't be doing heavy math of cybersecurity & crypto
	- won't cover making your own self-made auth sys (OAuth 2 server)
1. Authentication vs Authorization
*	- Authentication: process of verifying you are who you say you are (any login!)
		- e.g. picture on passport. BUT not foolproof
		- e.g. authenticity of artifacts through carbon dating
		- e.g. visit Paypal and getg certificate saying browser verifies it's Paypal
		- e.g. password
	- ALWAYS people trying to cheat the system when system tries to verify truth of sth
	- A LOT goes into authentication system:
		- strong pwds
		- strong encryption (algorithm)
		- secure client/server communication
		- securing pwd storage in encrypted db
		- pwd recovery quickly and securely
		- 2-factor authentication (pwd plus a special key)
		- protect against man-in-the-middle attacks
	- Implementing those features is hard. Some on client, some server. Sometimes both.
		- strong pwds only on client side (JS) allows users to mimick by faking http req
		- man in the middle protection also must be done on both endpoints
	- Has someone solved these problems before? Yes! Ask a trusted third party.
		- auth checks their third-party security system and reports back to you
		- requires communication between all three parties
*	- User login to 3 party, get auth. I ask user permission. Then I access 3 party data.
	- BUT user doesn't want me to have EVERYTHING in their profile and data
*	- Authorization: process of verifying your right to resource you're trying to access
	- 3 party auth providers ask if you want to grant the website access to certain data
*	- also, think abt bash access controller. Even once logged in, cannot do everything
		- adduser
	- usu Authorization after Authentication, but these are disjoint sec processes
		- key to a back door gives you access without door caring who you are
		- coupons and discounts. You're authorized a discount without ID.
		- dropbox and drive allow sharing links without authenticating an ID
		- bash login as root rather than a particular user (this why often disallowed)
			- root is the user that authenticates and logs in registered users
		- authorization cookies once been authenticated. If steal, authrz without authnt
*			- that's called "Session Hijacking"
			- cookies as codes that allow browser to access data, reuse without login
	- OAuth as most widely used standard. OpenIDConnect is just built on OAuth 2.0
	- Pros:
		- don't have to encrypt and store user pwds (outsource auth to OAuth providers)
		- easier to register user (less friction)
		- less pwds for users to remember and you to be responsible for (e.g. leaks/site compromises)
	- Neutral:
		- need 3 party account (good if they have and like, annoying if they don't)
		- only support login via sites that are popular (cover large % of client base)
	- Cons:
		- users don't trust your site (privacy concern, e.g. posting to your FB)
		- as above, auth scopes that betray user trust (keep auth scopes minimal)
		- limited/restricted internet access
		- different auth requirements (e.g. need to change 2-factor auth or pwd strength)
	- OAuth 2.0 Playground is a Google webapp where devs can test making 
		developers.google.com/oauthplayground
		- trade code for token
		- we get an access token for 3600 secs, then get list of API calls we can use
		- Example request (passing token)
		
		GET /userinfo/v2/me HTTP/1.1
		Host: www.googleapis.com
		Content-length: 0
		Authorization: Bearer ya29.Glv_AwrcSLMy-oMw1dbhS9HlH4o2E1FVsuGI3nTiamE86wfeYkQqgYD1g4ahjeWU80ypa5jtIXG1WG6xZMBROdDedXTEDufnMpV9LaCvMzUR4iIgegHd4-oQBq_7

		- Example response
	
		HTTP/1.1 200 OK
		Content-length: 212
		X-xss-protection: 1; mode=block
		Content-location: https://www.googleapis.com/userinfo/v2/me
		X-content-type-options: nosniff
		Transfer-encoding: chunked
		Expires: Mon, 01 Jan 1990 00:00:00 GMT
		Vary: Origin, X-Origin
		Server: GSE
		-content-encoding: gzip
		Pragma: no-cache
		Cache-control: no-cache, no-store, max-age=0, must-revalidate
		Date: Mon, 27 Feb 2017 16:23:56 GMT
		X-frame-options: SAMEORIGIN
		Alt-svc: quic=":443"; ma=2592000; v="35,34"
		Content-type: application/json; charset=UTF-8
		{
		  "family_name": "", 
		  "name": "", 
		  "picture": "https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg", 
		  "locale": "en", 
		  "given_name": "", 
		  "id": "117667974869561719729"
		}

2. Creating a G+ Signin
	- Flow 1: initiated by browser in JS, passing token to G+ that's passed back
		- client-side is quick and easy
		- but trusts browser/mobile and server cannot make API calls for user
	- Flow 2: server side, server obtains the token on behalf of user (user can revoke)
		- server-side is more powerful
		- but server now responsible for implementing session tracking for users
		- secure storage and access tokens
*	- G+ hybridized flow: authent on client, but server makes API calls for client 
		https://developers.google.com/identity/protocols/OAuth2#scenarios
	- even if hack access code btwn server & G, can't do stuff w/o "client secret"
*	- /!\ CLONED REPO gives me trouble.
		- I can clone, bring up vagrant, ssh in and navigate to the oauth directory
		- I can see all the listed py files there
		- I can run the db create and the db populate scripts just fine
		- I can run the project startup script just fine
		- when I navigate to the localhost port I see nothing
		- issue continues when I change project py and copy/paste e.g. localhost:8020
*	- /!\ USE my FoodBase project instead! It works just fine.
*		- it's in a separate udacity-fullstack folder
*		- navigate to vagrant/, vagrant up, vagrant ssh, then to /vagrant/finalProject
*		- now let's implement oauth on this thing!
	(1) setup to communicate with API library at console.developers.google.com
		- create new project
		- API > credentials
		- create new client id
		- now have "Client ID", "Client secret" and "Creation date"
	(2) Configure local version of code to work
		- Edit Client Settings
		- find Authorized JS Origins
		- add localhost:port (where port is the 4 ints you're using)
		- if you're also using the IP version (0.0....), this needs added as well
	(3) Use client ID and secret to add OAuth to app
	- Anti-Forgery State Tokens
		- make sure that the user is actually the one doing a request
		- unique session token that client side returns alongside authorization token
		- in later steps, verify this unique session token w server on all reqs
	(4) imports for Login Session in Flask app

	from flask import session as login_session 	# this is a dict
	import random, string 	# to create pseudorandom string for each session

	(5) create showLogin that makes the state var (32 chars, mix uppercase + digits)
		- store that state as login_session['state'] to use later
	
	@app.route('/login')
	def showLogin():
		state = ''.join(random.choice(string.ascii_uppercase + string.digits) for x in xrange(32))
		login_session['state'] = state
		return "Current session state: %s" % login_session['state']

	 	- for x-site request forgery, attacker would have to guess this code to make a request on the user's behalf
	 	- later, we'll check to make sure user and login session have same state val

	(6) Make an actual button user can click to login
		- create new login template in project templates folder
		- inside the new template's <head> tags, include the following scripts
			<script src = "//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js">
			</script>
			<script src = "https://apis.google.com/js/client:platform.js?onload=start" async defer></script>
		- in the body, create a div to hold the actual G signin data
			<div id = "signinButton">
				<span class = "g-signin"
					data-scope = "openid"
					data-clientid = "YOUR CLIENT ID HERE"
					data-redirecturi = "postmessage"
					data-accesstype = "offline"
					data-cookiepolicy = "single_host_origin"
					data-callback = "signinCallback"
					data-approvalprompt = "force">
				</span>
			</div>
			<div id = "result"></div>
		- data-scope : which G resources we want to be able to access. Compare the documentation to see kind of info you'll get in res obj (e.g. name, email, ...)
			## should read "openid email" to retrieve a user's email
		- data-clientid : the client id value generated when creating project at console.developers.google.com
		- data-redirecturi : sends a post messg, enabling one-time use codeflow
		- data-accesstype : do you want to send api calls even if user not logged in?
		- data-cookiepolicy : scope of uri that can access cookie. Single origin if just one host name and no subdomains.
		- data-callback : the cb to pass onetime use code and access token if user grants access to profile data
		- data-approvalprompt : user must login each time visit the login page (no check for already logged in).  /!\ Debug friendly, but disable in production /!\

	(7) Change views.py login to render the login template
		return render_template ('login.html') 	 # but .php in my example

	(8) Vagrant up, run server and test /login endpoint!
		- Nothing interesting happens upon logging in... yet.

	- 